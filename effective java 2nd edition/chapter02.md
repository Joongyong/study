# 객체의 생성과 삭제

Topic.
1. 객체를 만들어야 하는 시점과 그 방법
2. 객체 생성을 피해야 하는 경우와 그 방법
3. 적절한 순간에 객체가 삭제되도록 보장하는 방법
4. 삭제 전에 반드시 이루어져야 하는 청소 작업들을 관리하는 방법

## 규칙 1 - 생성자 대신 정적 팩토리 메서드를 사용할 수 없는지 생각해 보라
##### 객체를 만드는 방법
1. 클래스에 public으로 선언된 `생성자`를 이용하는것.
2. 클래스에 public으로 선언된 `정적 팩토리 메서드(static factory method) - public static T method() {}` 를 추가하는것.

### 장점 1. 정적 팩토리 메서드에는 이름(name)이 있다.
##### 메서드에 이름이 있다는게 어떤 장점이 있나?
생성자에 전달되는 파라미터들은 어떤 객체가 생성되는지를 설명하지 못하지만 정적 팩토리 메서드는 이름을 잘 짓기만 한다면 사용하기도 쉽고, 클라이언트 코드의 가독성도 높아진다.

아래의 코드 처럼 BigInteger(int, int, Random)는 BigInteger.probablePrime과 같은 이름의 정적 팩토리 메서드로 표현했으면 더 이해하기가 쉽다.
```java
new BigInteger(int, int, Random); // 생성자 - 정확하게 어떤 객체를 생성하는지 이해하기 어렵다 

BigInteger.probablePrime()        // 정적 팩토리 메서드 - 위의 코드에 비해 메소드 이름으로 인해 이해하기 쉽다 
```

클래스에는 시그니처별로 하나의 생성자만 넣을 수 있다. 
이 제약을 피하는 한 가지 방법은 인자의 순서를 바꾸는 것이다. 
이런 생성자를 사용하면 `API를 참조하지 않고는 코드가 하는 일을 제대로 파악하지 못할 것이다.`
송금을 위한 클래스로 예를 들어보자.
인자 순서를 바꿈으로 인해 심각한 문제가 발생할수도 있다.

```java
public Withdrawl(String send, String receive){
    ...
}

// 시그니처별로 하나의 생성자만 넣을수 있는 제약을 피하기 위해 인자의 순서를 변경
public Withdrawl(String receive, String send){ 
    ...
}
```

반면 정적 팩토리 메서드에는 이름이 있으므로 그런 문제는 생기지 않는다. 
같은 시그니처를 갖는 생성자를 여러 개 정의할 필요가 있을 때는 그 생성자들을 정적 팩토리 메서드로 바꾸고, 메서드 이름을 보면 차이가 명확히 드러나도록 작명에 신경 쓰자.
```java
public static Withdrawl sendToReciver() {
    ...
}
public static Withdrawl withdrawlFromSender() {
    ...
}
```

### 장점 2. 호출할 때마다 새로운 객체를 생성할 필요는 없다.
변경 불가능 클래스라면 이미 만들어 둔 객체를 활용할 수도 있고, 만든 객체를 캐시(cache) 해놓고 재사용하여 같은 객체가 불필요하게 거듭 생성되는 일을 피할 수도 있다. 앞서 살펴본 `Boolean.valueOf(Boolean)` 메서드는 이 기법을 활용한 좋은 사례다. 결코 객체를 생성하지 않는 것이다. 이 기법은 `경량(Flyweight) 패턴`과 유사하다. 동일한 객체가 요청되는 일이 잦고, 특히 객체를 만드는 비용이 클 때 적용하면 성능을 크게 개선할 수 있다.

`객체를 만드는 비용이 클 때`가 어떤 의미인가?

`정적 팩토리 메서드(static factory method)`를 사용하면 같은 객체를 반복해서 반환할 수 있으므로 어떤 시점에 어떤 객체가 얼마나 존재할지를 정밀하게 제어할 수 있다. 
그런 기능을 갖춘 클래스는 `개체 통제 클래스(instance-controlled class)`라고 부른다. `개체 통제 클래스`를 작성하는 이유는 몇 가지가 있다. 
개체 수를 제어하면 `싱글턴(singleton) 패턴`을 따르도록 할 수 있고, 객체 생성이 불가능한 클래스를 만들 수도 있다. 
변경이 불가능한 클래스의 경우 두개의 같은 객체가 존재하지 못하도록 할 수도 있다. 즉, `a == b`  일때만 `a.equals(b)`가 참이 되도록 만들 수 있다는 것이다. 
이렇게 구현된 클래스는 `equals(Object)` 대신 `== 연산자`를 사용하여 비교할 수 있으므로 성능이 향상 된다. `열거 자료형(enum)`이 이 기법을 사용한다.

### 장점 3. 반환값 자료형의 하위 자료형 객체를 반환할 수 있다.
반환되는 객체의 클래스를 훨씬 유연하게 결정할 수 있다.
이 유연성을 활용하면 public으로 선언되지 않은 클래스의 객체를 반환하는 API를 만들 수 있다. ?????? 어떻게?????
이 기법은 인터페이스 기반 프레임워크 구현에 적합, 이 프레임워크에서 인터페이스는 정적 팩토리 메서드의 반환값 자료형으로 이용
인터페이스는 정적 메서드를 가질 수 없으므로, 관습상 반환값 자료형이 Type이라는 이름의 인터페이스인 정적 팩토리 메서드는 Types라는 이름의 객체 생성 불가능 클래스 안에 둔다.

### 장점 3. 형인자 자료형(parameterized type) 객체를 만드 때 편하다는 점이다.
```java
Map<String, List<String>> m = new HashMap<String, List<String>();
```
위처럼 자료형 명세를 중복하면, 형인자가 늘어남에 따라 길고 복잡한 코드가 만들어진다.
하지만 정적 팩토리 메서드를 사용하면 컴파일러가 형인자를 스스로 알아내도록 할수 있다.
이런 기법을 자료형 유추(tyep inference)라고 부른다.
Java 1.6 이전에는 유용했지만 1.7 이후에는 지원이 되기때문데 무의미해졌다.

### 단점 1. public이나 protected로 선언된 생성자가 없으므로 하위 클래스를 만들 수 없다는 것.
논쟁의 소지가 있긴 하지만 그래서 더 좋다는 사람도 있는데, 계승(inheritance) 대신 구성(composition) 기법을 쓰도록 장려한다는 이유에서다.

### 단점 2. 정적 팩토리 메서드가 다른 정적 메서드와 확연히 구분되지 않는다는 것.
API 문서를 보면 생성자는 다른 메서드와 뚜렷이 구별되지만, 정적 팩토리 메서드는 그렇지 않다.
정적 팩토리 메서드를 통해 객체를 만들어야 하는 클래스는 사용법을 파악하기 쉽지 않다.


## Summary
- 정적 팩토리 메서드와 public 생성자는 용도가 서로 다르다.
- 차이와 장단점을 이해하는 것이 중요하다.
- 정적 팩토리 메서드가 효과적인 경우가 많으니 무조건 public 생성자를 만드는것보다 정적 팩토리 메서드를 고려해보자.

